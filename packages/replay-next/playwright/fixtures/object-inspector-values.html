<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <meta content="utf-8" http-equiv="encoding" />
  </head>
  <body>
    <script type="text/javascript">
      function regularFunction() {}
      const arrowFunction = (requiredParam, optionalParam = 123) => {};
      const boundFunction = regularFunction.bind(this);
      const overflowingFunction = (
        a,
        b,
        c,
        d,
        e,
        f,
        g,
        h,
        i,
        j,
        k,
        l,
        m,
        n,
        o,
        p,
        q,
        r,
        s,
        t,
        u,
        v,
        w,
        x,
        y,
        z
      ) => {};

      const booleanFalse = false;
      const booleanTrue = true;
      const numberNaN = NaN;
      const number = 123;
      const infinity = Infinity;
      const negativeInfinity = Number.NEGATIVE_INFINITY;
      const maxSafeInteger = Number.MAX_SAFE_INTEGER;
      const bigInt = BigInt(123);
      const string = "text";
      const specialNull = null;
      const specialUndefined = undefined;
      const date = new Date();
      const error = new Error("This is an error");

      const emptyObject = {};
      const object = { foo: 123, bar: "abc", baz: true };
      const objectWithNullPrototype = Object.create(null);
      const objectWithGettersAndSetters = {
        get numberGetter() {
          return 123;
        },
        get nullGetter() {
          return null;
        },
        get undefinedGetter() {
          return undefined;
        },
        get arrayGetter() {
          return [123, "abc", true];
        },
        get objectGetter() {
          return { foo: 123, bar: "abc", baz: true };
        },

        _string: "initial",
        get stringGetterSetter() {
          return this._string;
        },
        set stringGetterSetter(value) {
          this._string = value;
        },

        _boolean: false,
        set booleanSetter(value) {
          this._boolean = value;
        },
      };

      class BaseClass {
        instanceProperty = ["a", "b", "c"];
        static staticProperty = "text";
        constructor(param, paramWithDefaults = 123) {}
        get getter() {
          return this.instanceProperty;
        }
        get setterGetterPair() {
          return this._setterGetterPair;
        }
        set setterGetterPair(value) {
          this._setterGetterPair = value;
        }
        instanceMethod(param) {}
        boundInstanceMethod = (paramWithDefaults = 123) => {};
        static staticMethod() {}
      }
      class SubClass extends BaseClass {
        constructor(foo, bar) {
          super(foo);
        }
        // Override
        instanceMethod(a, b, c) {}
      }

      const emptyArray = [];
      const array4 = [1, 2, 3, 4];
      const array5 = [1, 2, 3, 4, 5];
      const array6 = [1, 2, 3, 4, 5, 6];
      const overflowingArray = [];
      for (let i = 0; i < 105; i++) {
        overflowingArray.push(String.fromCharCode(32 + i));
      }
      const arrayWithObjects = [{ foo: 123, bar: "abc" }, [1, 2]];
      const arrayThatNeedsBucketing = new Array(205).fill(true).map((_, index) => index);

      const int8Array = Int8Array.from([1, 2, 3]);
      const uint8Array = Uint8Array.from([1, 2, 3]);
      const uint8ClampedArray = Uint8ClampedArray.from([1, 2, 3]);
      const int16Array = Int16Array.from([1, 2, 3]);
      const uint16Array = Uint16Array.from([1, 2, 3]);
      const int32Array = Int32Array.from([1, 2, 3]);
      const uint32Array = Uint32Array.from([1, 2, 3]);
      const float32Array = Float32Array.from([1, 2, 3]);
      const float64Array = Float64Array.from([1, 2, 3]);
      const bigInt64Array = BigInt64Array.from([BigInt(1), BigInt(2), BigInt(3)]);
      const bigUint64Array = BigUint64Array.from([BigInt(1), BigInt(2), BigInt(3)]);

      const htmlText = document.createTextNode("Text node");
      const htmlElement = document.createElement("div");
      const htmlElementWithProps = document.createElement("title");
      htmlElementWithProps.className = "Header";
      htmlElementWithProps.title = "Click me to login";
      const htmlElementWithAttributes = document.createElement("button");
      htmlElementWithAttributes.setAttribute("name", "loginButton");
      htmlElementWithAttributes.setAttribute("disabled", true);
      htmlElementWithAttributes.textContent = "Login";
      const htmlElementWithStyle = document.createElement("div");
      htmlElementWithStyle.style = "background-color: yellow; color: black;";
      const htmlElementWithChildren = document.createElement("ul");
      const listItemOne = document.createElement("li");
      listItemOne.className = "Header";
      listItemOne.style = "background-color: yellow; color: black;";
      listItemOne.textContent = "First item";
      const listItemTwo = document.createElement("li");
      const child = document.createElement("div");
      child.textContent = "Second item";
      listItemTwo.appendChild(child);
      listItemTwo.appendChild(document.createTextNode("Text node"));
      htmlElementWithChildren.appendChild(listItemOne);
      htmlElementWithChildren.appendChild(listItemTwo);
      htmlElementWithChildren.appendChild(document.createElement("li"));

      const regex = /abc[123]+/i;
      const symbol = Symbol.for("example");

      const emptyMap = new Map();
      const map = new Map([
        ["one", 1],
        ["two", "blah"],
        ["three", true],
        ["four", new Map()],
      ]);
      const mapWithFalsyKeys = new Map([
        [null, "null"],
        [undefined, "undefined"],
        [false, "false"],
        [0, "zero"],
      ]);
      const mapWithComplexKeys = new Map([
        [{ foo: "bar" }, "object"],
        [[1, 2, 3], "array"],
        [new Set([1, 2, 3]), "Set"],
        [
          new Map([
            ["one", 123],
            ["two", true],
          ]),
          "map",
        ],
      ]);
      const weakMap = new WeakMap([
        [regex, "abc"],
        [map, 123],
      ]);
      const overflowingMap = new Map(Object.entries(overflowingArray));
      const emptySet = new Set();
      const set = new Set([1, "two", true, new Set()]);
      const weakSet = new WeakSet([regex, set]);
      const overflowingSet = new Set(overflowingArray);
      const arrayOfHtmlElements = [
        htmlElement,
        htmlElementWithAttributes,
        htmlElementWithProps,
        htmlElementWithChildren,
        htmlElementWithProps,
      ];

      // Note that the naming and ordering of properties in the object below is significant.
      // The corresponding Playwright tests may operate on the first match for a given locator/selector.
      const complexObject = {
        // Simple props first
        specialNull,
        specialUndefined,
        string,
        booleanFalse,
        booleanTrue,
        number,
        numberNaN,
        infinity,
        negativeInfinity,
        maxSafeInteger,
        bigInt,
        symbol,

        // Various function types
        regularFunction,
        arrowFunction,
        boundFunction,
        overflowingFunction,

        // Various object types
        filter_objectEmpty: emptyObject,
        filter_objectSimple: object,
        filter_objectWithNullPrototype: objectWithNullPrototype,
        filter_objectWithGettersAndSetters: objectWithGettersAndSetters,

        // HTML elements
        filter_htmlElement: htmlElement,
        filter_htmlElementWithProps: htmlElementWithProps,
        filter_htmlElementWithStyle: htmlElementWithStyle,
        filter_htmlElementWithAttributes: htmlElementWithAttributes,
        filter_htmlElementWithChildren: htmlElementWithChildren,
        filter_htmlText: htmlText,

        // Various array types
        emptyArray,
        arrayLength4: array4,
        arrayLength5: array5,
        arrayLength6: array6,
        arrayWithObjects,
        overflowingArray,
        arrayOfHtmlElements,
        arrayThatNeedsBucketing,
        int8Array,
        uint8Array,
        uint8ClampedArray,
        int16Array,
        uint16Array,
        int32Array,
        uint32Array,
        float32Array,
        float64Array,
        bigInt64Array,
        bigUint64Array,

        // Special object types
        date,
        error,
        regex,
        emptyMap,
        simpleMap: map,
        weakMap,
        overflowingMap,
        mapWithFalsyKeys,
        mapWithComplexKeys,
        emptySet,
        simpleSet: set,
        weakSet,
        overflowingSet,

        // Classes and instances
        BaseClass,
        SubClass,
        baseClass: new BaseClass(),
        subClass: new SubClass(),
      };

      // Circular references
      complexObject.circular = complexObject;

      // Log some basic string substitution and styling.
      console.log("text", 123, true, false);
      console.log("%c foo %s bar %s baz", "color: red;", 123, true);

      // Log individual values to simplify testing.
      Object.entries(complexObject).forEach(([key, value]) => {
        console.log(key, value);
      });

      // Log the entire object
      console.log("Entire object:", complexObject);
    </script>
  </body>
</html>
